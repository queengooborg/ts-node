{"version":3,"file":"testlib.js","sourceRoot":"","sources":["../../src/test/testlib.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Extensions to ava, for declaring and running test cases and suites\n * Utilities specific to testing ts-node, for example handling streams and exec-ing processes,\n * should go in a separate module.\n */\n\nimport avaTest, {\n  ExecutionContext,\n  Implementation,\n  OneOrMoreMacros,\n} from 'ava';\nimport * as assert from 'assert';\nimport throat from 'throat';\nimport * as expect from 'expect';\n\nexport { ExecutionContext, expect };\n\n// HACK ensure ts-node-specific bootstrapping is executed\nimport './helpers';\n\n// NOTE: this limits concurrency within a single process, but AVA launches\n// each .spec file in its own process, so actual concurrency is higher.\nconst concurrencyLimiter = throat(16);\n\nfunction errorPostprocessor<T extends Function>(fn: T): T {\n  return async function (this: any) {\n    try {\n      return await fn.call(this, arguments);\n    } catch (error: any) {\n      delete error?.matcherResult;\n      // delete error?.matcherResult?.message;\n      if (error?.message) error.message = `\\n${error.message}\\n`;\n      throw error;\n    }\n  } as any;\n}\n\nfunction once<T extends Function>(func: T): T {\n  let run = false;\n  let ret: any = undefined;\n  return function (...args: any[]) {\n    if (run) return ret;\n    run = true;\n    ret = func(...args);\n    return ret;\n  } as any as T;\n}\n\nexport const test = createTestInterface({\n  beforeEachFunctions: [],\n  mustDoSerial: false,\n  automaticallyDoSerial: false,\n  automaticallySkip: false,\n  // The little right chevron used by ava\n  separator: ' \\u203a ',\n  titlePrefix: undefined,\n});\n// In case someone wants to `const test = context()`\nexport const context = test.context;\n\nexport interface TestInterface<\n  Context\n> /*extends Omit<AvaTestInterface<Context>, 'before' | 'beforeEach' | 'after' | 'afterEach' | 'failing' | 'serial'>*/ {\n  //#region copy-pasted from ava's .d.ts\n  /** Declare a concurrent test. */\n  (title: string, implementation: Implementation<Context>): void;\n  /** Declare a concurrent test that uses one or more macros. Additional arguments are passed to the macro. */\n  <T extends any[]>(\n    title: string,\n    macros: OneOrMoreMacros<T, Context>,\n    ...rest: T\n  ): void;\n  /** Declare a concurrent test that uses one or more macros. The macro is responsible for generating a unique test title. */\n  <T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n  //#endregion\n\n  serial(title: string, implementation: Implementation<Context>): void;\n  /** Declare a concurrent test that uses one or more macros. Additional arguments are passed to the macro. */\n  serial<T extends any[]>(\n    title: string,\n    macros: OneOrMoreMacros<T, Context>,\n    ...rest: T\n  ): void;\n  /** Declare a concurrent test that uses one or more macros. The macro is responsible for generating a unique test title. */\n  serial<T extends any[]>(\n    macros: OneOrMoreMacros<T, Context>,\n    ...rest: T\n  ): void;\n  skip(title: string, implementation: Implementation<Context>): void;\n  /** Declare a concurrent test that uses one or more macros. Additional arguments are passed to the macro. */\n  skip<T extends any[]>(\n    title: string,\n    macros: OneOrMoreMacros<T, Context>,\n    ...rest: T\n  ): void;\n  /** Declare a concurrent test that uses one or more macros. The macro is responsible for generating a unique test title. */\n  skip<T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n\n  macro<Args extends any[], Ctx = Context>(\n    cb: (\n      ...args: Args\n    ) =>\n      | [\n          ((title: string | undefined) => string | undefined) | string,\n          (t: ExecutionContext<Ctx>) => Promise<void>\n        ]\n      | ((t: ExecutionContext<Ctx>) => Promise<void>)\n  ): AvaMacro<Args, Ctx>;\n\n  beforeAll(cb: (t: ExecutionContext<Context>) => Promise<void>): void;\n  beforeEach(cb: (t: ExecutionContext<Context>) => Promise<void>): void;\n  context<T extends object | void>(\n    cb: (t: ExecutionContext<Context>) => Promise<T>\n  ): TestInterface<Context & T>;\n  suite(title: string, cb: (test: TestInterface<Context>) => void): void;\n\n  runSerially(): void;\n\n  /** Skip tests unless this condition is met */\n  skipUnless(conditional: boolean): void;\n  /** If conditional is true, run tests, otherwise skip them */\n  runIf(conditional: boolean): void;\n  /** If conditional is false, skip tests */\n  skipIf(conditional: boolean): void;\n\n  // TODO add teardownEach\n}\nexport interface AvaMacro<Args extends any[] = any[], Ctx = unknown> {\n  (test: ExecutionContext<Ctx>, ...args: Args): Promise<void>;\n  title?(givenTitle: string | undefined, ...args: Args): string;\n}\n\nfunction createTestInterface<Context>(opts: {\n  titlePrefix: string | undefined;\n  separator: string | undefined;\n  mustDoSerial: boolean;\n  automaticallyDoSerial: boolean;\n  automaticallySkip: boolean;\n  beforeEachFunctions: Function[];\n}): TestInterface<Context> {\n  const { titlePrefix, separator = ' > ' } = opts;\n  const beforeEachFunctions = [...(opts.beforeEachFunctions ?? [])];\n  let { mustDoSerial, automaticallyDoSerial, automaticallySkip } = opts;\n  let hookDeclared = false;\n  let suiteOrTestDeclared = false;\n  function computeTitle<Args extends any[]>(\n    title: string | undefined,\n    macros?: AvaMacro<Args, any>[],\n    ...args: Args\n  ) {\n    for (const macro of macros ?? []) {\n      if (macro.title) {\n        title = macro.title(title, ...args);\n      }\n    }\n    assert(title);\n    // return `${ titlePrefix }${ separator }${ title }`;\n    if (titlePrefix != null && title != null) {\n      return `${titlePrefix}${separator}${title}`;\n    }\n    if (titlePrefix == null && title != null) {\n      return title;\n    }\n  }\n  function parseArgs(args: any[]) {\n    const title =\n      typeof args[0] === 'string' ? (args.shift() as string) : undefined;\n    const macros =\n      typeof args[0] === 'function'\n        ? [args.shift() as AvaMacro]\n        : Array.isArray(args[0])\n        ? (args.shift() as AvaMacro[])\n        : [];\n    return { title, macros, args };\n  }\n  function assertOrderingForDeclaringTest() {\n    suiteOrTestDeclared = true;\n  }\n  function assertOrderingForDeclaringHook() {\n    if (suiteOrTestDeclared) {\n      throw new Error(\n        'Hooks must be declared before declaring sub-suites or tests'\n      );\n    }\n    hookDeclared = true;\n  }\n  function assertOrderingForDeclaringSkipUnless() {\n    if (suiteOrTestDeclared) {\n      throw new Error(\n        'skipUnless or runIf must be declared before declaring sub-suites or tests'\n      );\n    }\n  }\n  /**\n   * @param avaDeclareFunction either test or test.serial\n   */\n  function declareTest(\n    title: string | undefined,\n    macros: AvaMacro<any[], Context>[],\n    avaDeclareFunction: Function & { skip: Function },\n    args: any[],\n    skip = false\n  ) {\n    const wrappedMacros = macros.map((macro) => {\n      return async function (t: ExecutionContext<Context>, ...args: any[]) {\n        return concurrencyLimiter(\n          errorPostprocessor(async () => {\n            let i = 0;\n            for (const func of beforeEachFunctions) {\n              await func(t);\n              i++;\n            }\n            return macro(t, ...args);\n          })\n        );\n      };\n    });\n    const computedTitle = computeTitle(title, macros, ...args);\n    (automaticallySkip || skip ? avaDeclareFunction.skip : avaDeclareFunction)(\n      computedTitle,\n      wrappedMacros,\n      ...args\n    );\n  }\n  function test(...inputArgs: any[]) {\n    assertOrderingForDeclaringTest();\n    // TODO is this safe to disable?\n    // X parallel tests will each invoke the beforeAll hook, but once()ification means each invocation will return the same promise, and tests cannot\n    // start till it finishes.\n    // HOWEVER if it returns a single shared state, can tests concurrently use this shared state?\n    // if(!automaticallyDoSerial && mustDoSerial) throw new Error('Cannot declare non-serial tests because you have declared a beforeAll() hook for this test suite.');\n    const { args, macros, title } = parseArgs(inputArgs);\n    return declareTest(\n      title,\n      macros,\n      automaticallyDoSerial ? avaTest.serial : avaTest,\n      args\n    );\n  }\n  test.serial = function (...inputArgs: any[]) {\n    assertOrderingForDeclaringTest();\n    const { args, macros, title } = parseArgs(inputArgs);\n    return declareTest(title, macros, avaTest.serial, args);\n  };\n  test.skip = function (...inputArgs: any[]) {\n    assertOrderingForDeclaringTest();\n    const { args, macros, title } = parseArgs(inputArgs);\n    return declareTest(title, macros, avaTest, args, true);\n  };\n  test.beforeEach = function (\n    cb: (test: ExecutionContext<Context>) => Promise<void>\n  ) {\n    assertOrderingForDeclaringHook();\n    beforeEachFunctions.push(cb);\n  };\n  test.context = function (\n    cb: (test: ExecutionContext<Context>) => Promise<any>\n  ) {\n    assertOrderingForDeclaringHook();\n    beforeEachFunctions.push(async (t: ExecutionContext<Context>) => {\n      const addedContextFields = await cb(t);\n      Object.assign(t.context, addedContextFields);\n    });\n    return test;\n  };\n  test.beforeAll = function (\n    cb: (test: ExecutionContext<Context>) => Promise<void>\n  ) {\n    assertOrderingForDeclaringHook();\n    mustDoSerial = true;\n    beforeEachFunctions.push(once(cb));\n  };\n  test.macro = function <Args extends any[]>(\n    cb: (\n      ...args: Args\n    ) =>\n      | [\n          ((title: string | undefined) => string | undefined) | string,\n          (t: ExecutionContext<Context>) => Promise<void>\n        ]\n      | ((t: ExecutionContext<Context>) => Promise<void>)\n  ) {\n    function macro(testInterface: ExecutionContext<Context>, ...args: Args) {\n      const ret = cb(...args);\n      const macroFunction = Array.isArray(ret) ? ret[1] : ret;\n      return macroFunction(testInterface);\n    }\n    macro.title = function (givenTitle: string | undefined, ...args: Args) {\n      const ret = cb(...args);\n      return Array.isArray(ret)\n        ? typeof ret[0] === 'string'\n          ? ret[0]\n          : ret[0](givenTitle)\n        : givenTitle;\n    };\n    return macro;\n  };\n  test.suite = function (\n    title: string,\n    cb: (test: TestInterface<Context>) => void\n  ) {\n    suiteOrTestDeclared = true;\n    const newApi = createTestInterface<Context>({\n      mustDoSerial,\n      automaticallyDoSerial,\n      automaticallySkip,\n      separator,\n      titlePrefix: computeTitle(title),\n      beforeEachFunctions,\n    });\n    cb(newApi);\n  };\n  test.runSerially = function () {\n    automaticallyDoSerial = true;\n  };\n  test.skipUnless = test.runIf = function (runIfTrue: boolean) {\n    assertOrderingForDeclaringSkipUnless();\n    automaticallySkip = automaticallySkip || !runIfTrue;\n  };\n  test.skipIf = function (skipIfTrue: boolean) {\n    test.runIf(!skipIfTrue);\n  };\n  return test as any;\n}\n"]}