{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../src/test/repl/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import { PassThrough } from 'stream';\nimport { delay, getStream, TEST_DIR, tsNodeTypes, ctxTsNode } from '../helpers';\nimport type { ExecutionContext } from 'ava';\nimport { test, expect } from '../testlib';\n\nexport interface CreateReplViaApiOptions {\n  registerHooks: boolean;\n  createReplOpts?: Partial<tsNodeTypes.CreateReplOptions>;\n  createServiceOpts?: Partial<tsNodeTypes.CreateOptions>;\n}\n\nexport interface ExecuteInReplOptions extends CreateReplViaApiOptions {\n  waitMs?: number;\n  waitPattern?: string | RegExp;\n  /** When specified, calls `startInternal` instead of `start` and passes options */\n  startInternalOptions?: Parameters<\n    tsNodeTypes.ReplService['startInternal']\n  >[0];\n}\n\nexport namespace ctxRepl {\n  export type Ctx = ctxTsNode.Ctx & Awaited<ReturnType<typeof ctxRepl>>;\n  export type T = ExecutionContext<Ctx>;\n}\n\n/**\n * pass to test.context() to get REPL testing helper functions\n */\nexport async function ctxRepl(t: ctxTsNode.T) {\n  const { tsNodeUnderTest } = t.context;\n  return { createReplViaApi, executeInRepl };\n\n  function createReplViaApi({\n    registerHooks,\n    createReplOpts,\n    createServiceOpts,\n  }: CreateReplViaApiOptions) {\n    const stdin = new PassThrough();\n    const stdout = new PassThrough();\n    const stderr = new PassThrough();\n    const replService = tsNodeUnderTest.createRepl({\n      stdin,\n      stdout,\n      stderr,\n      ...createReplOpts,\n    });\n    const service = (\n      registerHooks ? tsNodeUnderTest.register : tsNodeUnderTest.create\n    )({\n      ...replService.evalAwarePartialHost,\n      project: `${TEST_DIR}/tsconfig.json`,\n      ...createServiceOpts,\n      tsTrace: replService.console.log.bind(replService.console),\n    });\n    replService.setService(service);\n    t.teardown(async () => {\n      service.enabled(false);\n    });\n\n    return { stdin, stdout, stderr, replService, service };\n  }\n\n  async function executeInRepl(input: string, options: ExecuteInReplOptions) {\n    const {\n      waitPattern,\n      // Wait longer if there's a signal to end it early\n      waitMs = waitPattern != null ? 20e3 : 1e3,\n      startInternalOptions,\n      ...rest\n    } = options;\n    const { stdin, stdout, stderr, replService } = createReplViaApi(rest);\n\n    if (startInternalOptions) {\n      replService.startInternal(startInternalOptions);\n    } else {\n      replService.start();\n    }\n\n    stdin.write(input);\n    stdin.end();\n    const stdoutPromise = getStream(stdout, waitPattern);\n    const stderrPromise = getStream(stderr, waitPattern);\n    // Wait for expected output pattern or timeout, whichever comes first\n    await Promise.race([delay(waitMs), stdoutPromise, stderrPromise]);\n    stdout.end();\n    stderr.end();\n\n    return {\n      stdin,\n      stdout: await stdoutPromise,\n      stderr: await stderrPromise,\n    };\n  }\n}\n\nexport const macroReplNoErrorsAndStdoutContains = test.macro(\n  (script: string, contains: string, options?: Partial<ExecuteInReplOptions>) =>\n    async (t: ctxRepl.T) => {\n      macroReplInternal(t, script, contains, undefined, contains, options);\n    }\n);\nexport const macroReplStderrContains = test.macro(\n  (\n      script: string,\n      errorContains: string,\n      options?: Partial<ExecuteInReplOptions>\n    ) =>\n    async (t: ctxRepl.T) => {\n      macroReplInternal(\n        t,\n        script,\n        undefined,\n        errorContains,\n        errorContains,\n        options\n      );\n    }\n);\n\nasync function macroReplInternal(\n  t: ctxRepl.T,\n  script: string,\n  stdoutContains: string | undefined,\n  stderrContains: string | undefined,\n  waitPattern: string,\n  options?: Partial<ExecuteInReplOptions>\n) {\n  const { stdout, stderr } = await t.context.executeInRepl(script, {\n    registerHooks: true,\n    startInternalOptions: { useGlobal: false },\n    waitPattern,\n    ...options,\n  });\n  if (stderrContains) expect(stderr).toContain(stderrContains);\n  else expect(stderr).toBe('');\n  if (stdoutContains) expect(stdout).toContain(stdoutContains);\n}\n"]}